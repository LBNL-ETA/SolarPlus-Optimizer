# coding: utf-8

# In[61]:


#!/usr/bin/env python
'''
Pymodbus Synchrnonous Client Test with Dynasonic DXN Energy Meter
--------------------------------------------------------------------------
The following is an example of how to use the synchronous modbus client
implementation from pymodbus. This has been adapted from a sample script
at https://pythonhosted.org/pymodbus/examples/synchronous-client.html
_Additional Note from sample script:
It should be noted that the client can also be used with
the guard construct that is available in python 2.5 and up::
    with ModbusClient('127.0.0.1') as client:
        result = client.read_coils(1,10)
        print result
***Created 2018-07-22 by Chris Weyandt
'''

#---------------------------------------------------------------------------#
# import the required server implementation
#---------------------------------------------------------------------------#
from pymodbus.client.sync import ModbusTcpClient
#from pymodbus.client.sync import ModbusUdpClient as ModbusClient
from pymodbus.client.sync import ModbusSerialClient

#additional imports for conversions
from pymodbus.constants import Endian
from pymodbus.payload import BinaryPayloadDecoder
from pymodbus.payload import BinaryPayloadBuilder
import configparser
import yaml
#---------------------------------------------------------------------------#
# configure the client logging
#---------------------------------------------------------------------------#
''''
import logging
logging.basicConfig()
log = logging.getLogger()
log.setLevel(logging.DEBUG)
'''

class Modbus_Driver(object):
    def __init__(self, config_file, config_section=None):
        if (config_section==None):
            modbus_section = 'modbus'
        with open(config_file) as f:
            # use safe_load instead load
            modbusConfig = yaml.safe_load(f)

        self.MODBUS_TYPE = modbusConfig[modbus_section]['modbus_type']
        if self.MODBUS_TYPE == 'serial':
            self.METHOD = modbusConfig[modbus_section]['method']
            self.SERIAL_PORT = modbusConfig[modbus_section]['port']
            self.STOPBITS = modbusConfig[modbus_section]['stopbits']
            self.BYTESIZE = modbusConfig[modbus_section]['bytesize']
            self.PARITY = modbusConfig[modbus_section]['parity']
            self.BAUDRATE = modbusConfig[modbus_section]['baudrate']
        elif self.MODBUS_TYPE == 'tcp':
            self.IP_ADDRESS = modbusConfig[modbus_section]['ip']
            self.PORT = modbusConfig[modbus_section]['port']
        else:
            print("Invalid modbus type")
            exit()

        self.UNIT_ID = modbusConfig[modbus_section]['UNIT_ID']
        self.OFFSET_REGISTERS = modbusConfig[modbus_section]['OFFSET_REGISTERS']

        if modbusConfig[modbus_section]['byte_order'] == 'big':
            self.BYTE_ORDER = Endian.Big
        elif modbusConfig[modbus_section]['byte_order'] == 'little':
            self.BYTE_ORDER = Endian.Little
        else:
            print("invalid byte order") # change to except later
            exit()
        if modbusConfig[modbus_section]['word_order'] == 'big':
            self.WORD_ORDER = Endian.Big
        elif modbusConfig[modbus_section]['word_order'] == 'little':
            self.WORD_ORDER = Endian.Little
        else:
            print("invalid byte order") # change to except later
            exit()

        self.coil_register_dict = modbusConfig[modbus_section]['coil_registers']
        self.discrete_register_dict = modbusConfig[modbus_section]['discrete_registers']
        self.holding_register_dict = modbusConfig[modbus_section]['holding_registers']
        self.input_register_dict = modbusConfig[modbus_section]['input_registers']

        for key in self.holding_register_dict:
            self.holding_register_dict[key][0] -= self.OFFSET_REGISTERS


    def initialize_modbus(self):
        if self.MODBUS_TYPE == 'serial':
            self.client= ModbusSerialClient(method = self.METHOD, port=self.SERIAL_PORT,stopbits = self.STOPBITS, bytesize = self.BYTESIZE, parity = self.PARITY, baudrate= self.BAUDRATE)
            connection = self.client.connect()

        if self.MODBUS_TYPE == 'tcp':
            self.client = ModbusTcpClient(self.IP_ADDRESS,port=self.PORT)

        '''
        print(self.coil_register_dict)
        print(self.discrete_register_dict)
        print(self.holding_register_dict)
        print(self.input_register_dict)
        '''


    def write_register_raw(self,register,value):
        response = self.client.write_register(register,value,unit= self.UNIT_ID)
        return response

    def write_register(self,register_name,value):
        """
        register_name -- register key from holding register dictionary
            generated by yaml config
        value -- value to write to register
        returns -- Nothing
        """
        builder = BinaryPayloadBuilder(byteorder=self.BYTE_ORDER,
            wordorder=self.WORD_ORDER)
        if (self.holding_register_dict[register_name][1] == '8int'):
            builder.add_8bit_int(value)
        elif (self.holding_register_dict[register_name][1] == '8uint'):
            builder.add_8bit_uint(value)
        elif (self.holding_register_dict[register_name][1] == '16int'):
            builder.add_16bit_int(value)
        elif (self.holding_register_dict[register_name][1] == '16uint'):
            builder.add_16bit_uint(value)
        elif (self.holding_register_dict[register_name][1] == '32int'):
            builder.add_32bit_int(value)
        elif (self.holding_register_dict[register_name][1] == '32uint'):
            builder.add_32bit_uint(value)
        elif (self.holding_register_dict[register_name][1] == '32float'):
            builder.add_32bit_float(value)
        elif (self.holding_register_dict[register_name][1] == '64int'):
            builder.add_64bit_int(value)
        elif (self.holding_register_dict[register_name][1] == '64uint'):
            builder.add_64bit_uint(value)
        elif (self.holding_register_dict[register_name][1] == '64float'):
            builder.add_64bit_float(value)
        else:
            print("Bad type")
            exit()
        payload = builder.build()
        self.client.write_registers(self.holding_register_dict[register_name][0], payload, skip_encode=True, unit = self.UNIT_ID)

    def write_coil(self,register,value):
        response = self.client.write_coil(register,value,unit= self.UNIT_ID)
        return response

    def read_coil(self,register):
        rr = self.client.read_coils(register, 1, unit=self.UNIT_ID)
        return rr.bits[0]

    def read_discrete(self,register):
        rr = self.client.read_discrete_inputs(register, count=1,unit= self.UNIT_ID)
        return rr.bits[0]

    def read_register_raw(self,register,length):
        #print(register)
        #print(length)
        response = self.client.read_holding_registers(register,length,unit= self.UNIT_ID)
        return response

    def read_input_raw(self,register,length):
        #print(register)
        #print(length)
        response = self.client.read_input_registers(register,length,unit= self.UNIT_ID)
        return response

    def decode_holding_register(self,register,type):
        #omitting string for now since it requires a specified length

        if type == '8int':
            rr = self.read_register_raw(register,1)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_8bit_int()

        elif type == '8uint':
            rr = self.read_register_raw(register,1)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_8bit_uint()
        elif type == '16int':
            rr = self.read_register_raw(register,1)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_16bit_int()
        elif type == '16uint':
            rr = self.read_register_raw(register,1)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_16bit_uint()
        elif type == '32int':
            rr = self.read_register_raw(register,2)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_32bit_int()
        elif type == '32uint':
            rr = self.read_register_raw(register,2)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_32bit_uint()
        elif type == '32float':
            rr = self.read_register_raw(register,2)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_32bit_float()
        elif type == '64int':
            rr = self.read_register_raw(register,4)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_64bit_int()
        elif type == '64uint':
            rr = self.read_register_raw(register,4)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_64bit_uint()
        elif type == 'ignore':
            rr = self.read_register_raw(register,1)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.skip_bytes(8)
        elif type == '64float':
            rr = self.read_register_raw(register,4)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_64bit_float()
        else:
            print("Wrong type specified")
            exit()

        return output

    def decode_input_register(self,register,type):
        #omitting string for now since it requires a specified length

        if type == '8int':
            rr = self.read_input_raw(register,1)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_8bit_int()

        elif type == '8uint':
            rr = self.read_input_raw(register,1)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_8bit_uint()
        elif type == '16int':
            rr = self.read_input_raw(register,1)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_16bit_int()
        elif type == '16uint':
            rr = self.read_input_raw(register,1)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_16bit_uint()
        elif type == '32int':
            rr = self.read_input_raw(register,2)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_32bit_int()
        elif type == '32uint':
            rr = self.read_input_raw(register,2)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_32bit_uint()
        elif type == '32float':
            rr = self.read_input_raw(register,2)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_32bit_float()
        elif type == '64int':
            rr = self.read_input_raw(register,4)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_64bit_int()
        elif type == '64uint':
            rr = self.read_input_raw(register,4)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_64bit_uint()
        elif type == 'ignore':
            rr = self.read_input_raw(register,1)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.skip_bytes(8)
        elif type == '64float':
            rr = self.read_input_raw(register,4)
            decoder = BinaryPayloadDecoder.fromRegisters(
                    rr.registers,
                    byteorder=self.BYTE_ORDER,
                    wordorder=self.WORD_ORDER)
            output = decoder.decode_64bit_float()
        else:
            print("Wrong type specified")
            exit()

        return output


    def get_data(self):
        output = {}
        for key in self.coil_register_dict:
            output[key] = self.read_coil(self.coil_register_dict[key][0])

        for key in self.discrete_register_dict:
            output[key] = self.read_discrete(self.discrete_register_dict[key][0])

        for key in self.holding_register_dict:
            output[key] = self.decode_holding_register(self.holding_register_dict[key][0],self.holding_register_dict[key][1])

        for key in self.input_register_dict:
            output[key] = self.decode_input_register(self.input_register_dict[key][0],self.input_register_dict[key][1])

        return output

    def get_data_raw(self):
        output = {}
        for key in self.coil_register_dict:
            output[key] = self.read_coil(self.coil_register_dict[key][0])

        for key in self.discrete_register_dict:
            output[key] = self.read_discrete(self.discrete_register_dict[key][0])

        for key in self.holding_register_dict:
            register = self.holding_register_dict[key][0]
            size = self.holding_register_dict[key][1]

            if size == '8int':
                rr = self.read_register_raw(register, 1)
            elif size == '8uint':
                rr = self.read_register_raw(register, 1)
            elif size == '16int':
                rr = self.read_register_raw(register, 1)
            elif size == '16uint':
                rr = self.read_register_raw(register, 1)
            elif size == '32int':
                rr = self.read_register_raw(register, 2)
            elif size == '32uint':
                rr = self.read_register_raw(register, 2)
            elif size == '32float':
                rr = self.read_register_raw(register, 2)
            elif size == '64int':
                rr = self.read_register_raw(register, 4)
            elif size == '64uint':
                rr = self.read_register_raw(register, 4)
            elif size == 'ignore':
                rr = self.read_register_raw(register, 1)
            elif size == '64float':
                rr = self.read_register_raw(register, 4)

            output[key] = rr

        for key in self.input_register_dict:
            register = self.holding_register_dict[key][0]
            size = self.holding_register_dict[key][1]

            if size == '8int':
                rr = self.read_register_raw(register, 1)
            elif size == '8uint':
                rr = self.read_register_raw(register, 1)
            elif size == '16int':
                rr = self.read_register_raw(register, 1)
            elif size == '16uint':
                rr = self.read_register_raw(register, 1)
            elif size == '32int':
                rr = self.read_register_raw(register, 2)
            elif size == '32uint':
                rr = self.read_register_raw(register, 2)
            elif size == '32float':
                rr = self.read_register_raw(register, 2)
            elif size == '64int':
                rr = self.read_register_raw(register, 4)
            elif size == '64uint':
                rr = self.read_register_raw(register, 4)
            elif size == 'ignore':
                rr = self.read_register_raw(register, 1)
            elif size == '64float':
                rr = self.read_register_raw(register, 4)

            output[key] = rr

        return output

    def get_single_register_data(self, register_name):
        if register_name in self.coil_register_dict.keys():
            return self.read_coil(self.coil_register_dict[register_name][0])

        elif register_name in self.discrete_register_dict.keys():
            return self.read_discrete(self.discrete_register_dict[register_name][0])

        elif register_name in self.holding_register_dict.keys():
            return self.decode_holding_register(self.holding_register_dict[register_name][0], self.holding_register_dict[register_name][1])

        elif register_name in self.input_register_dict.keys():
            return self.decode_input_register(self.input_register_dict[register_name][0], self.input_register_dict[register_name][1])

        else:
            print("cannot find register name: %s in config file"%register_name)

    def kill_modbus(self):
        self.client.close()
